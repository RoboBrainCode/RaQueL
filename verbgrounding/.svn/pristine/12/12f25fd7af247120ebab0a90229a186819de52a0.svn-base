/* Tell Me Dave 2013-14, Robot-Language Learning Project
 * Code developed by - Dipendra Misra (dkm@cs.cornell.edu)
 * working in Cornell Personal Robotics Lab.
 * 
 * More details - http://tellmedave.cs.cornell.edu
 * This is Version 2.0 - it supports data version 1.1, 1.2, 1.3
 */

/*  Notes for future Developers - 
 *    <no - note >
 */

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Xml;
using System.Diagnostics;
using WordsMatching;

namespace ProjectCompton
{
    class Inference
    {
        /* Class Description: The aim of this class is to provide several inference strategies
         * for the main algorithm. This also includes interface for inference moves
         * */
        public Logger lg = null;
        private List<VerbProgram> veil = null;
        private List<Environment> envList = null;
		public Features ftr { get; private set;}
        //private Double[] weights_opt = new double[13] { 10, 40, 2, -0.01, -10, 0, 5, 40, 130, 30, 0, 100, 0 };//null; // Weights used by the algorithm
        //private Dictionary<String, Double> weightsMainModel = new Dictionary<string, double>();
        //public int numFeatureMainModel = 9;
        private Parser obj = null;  // Parser objec
        //private int numFeature_opt = 13; //Number of Features to be used by the algorithm
        private Random rnd = null;  //Random Number Generator
        private SymbolicPlanner symp = null;
        public Simulator sml = null;
        private Learning lrn = null;
        private List<Tuple<Environment, Environment, double>> distanceMatrix = new List<Tuple<Environment, Environment, double>>();
		public SentenceSimilarity sensim = null;
        public System.IO.StreamWriter cacheQP = null;
        private XmlTextReader readQP = null;
		private Mapping map = null;
		public String oldvalue = null;

        public Inference(Logger lg, Simulator sml, SymbolicPlanner symp, List<VerbProgram> veil, List<Environment> envList, Parser obj, Features ftr)
        {
            this.lg = lg;
            this.veil = veil;
            this.envList = envList;
            this.ftr = ftr;
            this.obj = obj;
			this.symp = symp;
            this.rnd = new Random();
            this.sml = sml;
			this.map = new Mapping (this);
			this.sensim = new SentenceSimilarity ();
            if (Constants.cacheReadQP)
                this.readQP = new XmlTextReader(Constants.rootPath + "Log/QP.xml");
            if(Constants.cacheWriteQP)
            {
                this.cacheQP = new System.IO.StreamWriter(Constants.rootPath + "Log/QP.xml");
                this.cacheQP.WriteLine("<QP>");
            }
			if (Constants.cacheBootStrapSentenceSim)
				this.sensim.bootStrapCache ();
			Console.WriteLine ("Sentence Simiarity Cache Hit " + this.sensim.cacheHit / (this.sensim.cacheHit + this.sensim.cacheMiss + Constants.epsilon));
			this.lg.writeToFile ("Sentence Simiarity Cache Hit " + this.sensim.cacheHit / (this.sensim.cacheHit + this.sensim.cacheMiss + Constants.epsilon));
        }

		public List<object> initDict(List<double[]> weights)
		{
			//Function Description: Returns the dictionary bootstrapped with weights
			if (weights.Count () != Features.featureNames.Count ())
				throw new ApplicationException ("Number of weight vector parameters are not same as ");
			List<object> parameter = new List<object>();
			for(int i=0; i<weights.Count();i++)
			{
				Dictionary<String,Double> dict = new Dictionary<String,Double> ();
				for (int j=0; j<Features.featureNames[i].Count(); j++)
					dict.Add (Features.featureNames [i] [j], weights [i][j]);
				parameter.Add ((object)dict);
			}
			return parameter;
		}

        public void close()
        {
            //Function Description: Performs action as if this constructor is never going to be called again
            if (Constants.cacheWriteQP)
            {
                this.cacheQP.WriteLine("</QP>");
                this.cacheQP.Flush();
                this.cacheQP.Close();
            }
           if(Constants.cacheReadQP)
				this.readQP.Close();
			this.sensim.storeCache ();
        }
		
        public Tuple<Clause, List<Instruction>, Environment> trimItDown(Tuple<Clause, List<Instruction>, Environment> orig, int trim)
        {
            /* Function Description : Trim down the program from begining to depth of trim */
            List<Instruction> newInst = new List<Instruction>();
            for (int i = trim; i < orig.Item2.Count(); i++)
                newInst.Add(orig.Item2[i]);

            //Change the environment as well
            Environment iterator = orig.Item3.makeCopy();
            for (int i = 0; i < trim; i++)
            {
                Instruction inst = orig.Item2[i];
                inst = inst.makeCopyAndRevert();
                iterator = this.sml.execute(inst, iterator);
            }

            //copy the clause
            Clause cls = new Clause();
            cls = orig.Item1.makeCopy();

            return new Tuple<Clause, List<Instruction>, Environment>(cls, newInst, iterator);
        }

        public VeilTemplate trimItDown(VeilTemplate orig, int trim)
        {
            /* Function Description : Trim down the program from begining to depth of trim */
            List<Instruction> newInst = new List<Instruction>();
            for (int i = trim; i < orig.instOld.Count(); i++)
            {
                Instruction nw = orig.instOld[i].makeCopy();
                newInst.Add(nw);
            }

            foreach (Instruction itmp in newInst)
            {
                foreach (String dscp in itmp.getDescription())
                {
                    if (dscp[0] == '$')
                        throw new ApplicationException("Generalized Variables Exist");
                }
            }

            //Change the environment as well
			Environment iterator = orig.env_.makeCopy();
            for (int i = 0; i < trim; i++)
            {
                Instruction inst = orig.instOld[i];
                iterator = this.sml.execute(inst, iterator);
            }

            Clause cls = orig.cls_.makeCopy(); //copy the clause
            VeilTemplate trimmedDown = new VeilTemplate(cls, newInst, iterator, -1, this.sml);
            return trimmedDown;
        }

		public String expansion(List<List<String>> samePlurality, String cstr)
		{
			/* Function Description: Takes a constraint such as (On Pillow_1 ArmChair_1); 
			 * and given that there are samePlurality of Pillow_1; the algorithm expands 
			 * it to (On Pillow_1 ArmChair_1); (On Pillow_2 ArmChair_1);..(On Pillow_i ArmChair_1) 
			 * The algorithm : samePlurality(x) and Predicate(x,y) => and_i Predicate(x_i, y) */

			String[] cstrSplit = cstr.Split (new char[] {'^'});
			List<String> newConstraints = cstrSplit.ToList ();	
			foreach (List<String> same_ in samePlurality) 
			{
				if (same_.Count () == 1 || same_.Count() > 5 )
					continue;
				List<String> newlyAdded = new List<String> ();

				foreach(String pred in newConstraints)
				{
					//check if pred contains any object from same_
					int find = same_.FindIndex (obj => pred.Contains (obj));
					if(find!=-1)
					{
						for(int i=0; i< same_.Count();i++)
						{
							if (i == find)
								continue;
							Tuple<bool,string> atom = Global.getAtomic (pred);
							String[] words = atom.Item2.Split (new char[] {' '});
							for(int j=0; j<words.Length; j++)
							{
								if(words[j].Equals(same_[find]))
									words[j]=  same_[i];
							}
							String newpred = "("+string.Join(" ",words)+")";
							if (atom.Item1)
								newpred = "(not " + newpred + ")";
							newlyAdded.Add(newpred);
						}
					}
				}

				newConstraints = newConstraints.Union (newlyAdded).ToList();
			}
			return String.Join ("^", newConstraints);
		}

        public List<Instruction> instantiate(VeilTemplate eq, Clause cl, List<Tuple<String, String>> matchList)
        {
            /* To-Do */
            return null;
        }

        public List<Instruction> resetInstantiate(VeilTemplate eq)
        {
            /* To-Do */
            return null;
        }

        public List<Instruction> instantiation(VeilTemplate eq, int[] mapping, Environment envTest)
        {
            /* Function Description: Apply the mapping on the template and return
             * the instantiated instruction sequence */

            List<Instruction> insts = eq.inst_.ToList();
            List<Instruction> instant = new List<Instruction>();
            List<String> variables = eq.var_;
			List<Object> objList = envTest.objects;

            foreach (Instruction inst in insts)
            {
                List<String> description = inst.getDescription();
                List<String> newDescription = new List<String>();

                foreach (String dscp in description)
                {
                    bool added = false;
                    for (int i = 0; i < variables.Count(); i++)
                    {
                        if (dscp.Equals(variables[i]))
                        {
                            added = true;
                            newDescription.Add(objList[mapping[i]].uniqueName);
                            break;
                        }
                    }
                    if (!added)
                        newDescription.Add(dscp); //keep it same
                }
                Instruction instNew = new Instruction(inst.getControllerFunction(), newDescription);
                instant.Add(instNew);
            }

            return instant;
        }

		public List<String> instantiatePredicates(VeilTemplate vt, int[] mapping, Environment envTest)
		{
			/* Function Description: Takes a set of predicates [predicate] and mapping of the parameters to envTest
			 * and returns the instantiated predicates */
			List<String> instantiated = new List<String> ();
			List<Object> objList = envTest.objects;
			List<String> variables = vt.zVariablePredicatePost;
			foreach (String predicate in vt.predicatesPost) 
			{
				Tuple<bool,string> predicate_ = Global.getAtomic(predicate);
				String[] words = predicate_.Item2.Split (new char[]{' '});
				for(int i=0; i<words.Length;i++)
				{
					for (int v = 0; v < variables.Count(); v++)
					{
						if (words[i].Equals(variables[v]))
							words[i] = objList[mapping[v]].uniqueName;
					}
				}
				String instantiatedPred = "("+string.Join (" ", words)+")";
				if (predicate_.Item1)
					instantiatedPred = "(not " + instantiatedPred + ")";
				instantiated.Add (instantiatedPred);
			}
			return instantiated;
		}

        public Tuple<int[], Double> fetchMapFromCache()
        {
            /* Function Description: Cache has data in the format - 
               <QP>
             *  <pt><map>a1 a2 a3 ... </map><score>...</score></pt>
             *  .....
             * </QP>
             **/
            int[] map = null;
            while (this.readQP.Read())
            {
                switch (this.readQP.NodeType)
                {
                    case XmlNodeType.Text: //Display the text in each element.
                        if (map == null)
                            map = Global.stringToArray(this.readQP.Value);
                        else return new Tuple<int[], double>(map,Double.Parse(this.readQP.Value));
                        break;
                }
            }

            throw new ApplicationException("Asking from Cache where None exists");
        }

        public List<Tuple<String, String>> mapping(VeilTemplate eq, Clause clTest)
        {
            //Old Mapping. For temporary reasons
            return null;
        }

        public double getDistance(Environment env1, Environment env2)
        {
            /*Function Description : Finds the distance between the environment if not already stored
             * or just outputs the stored distance. The computed distance is then stored.*/
            foreach (Tuple<Environment, Environment, double> tmp in this.distanceMatrix)
            {
                if (tmp.Item1 == env1 && tmp.Item2 == env2 || tmp.Item1 == env2 && tmp.Item2 == env1)
                {
                    return tmp.Item3;
                }
            }
            double distance = env1.distance(env2);
            distanceMatrix.Add(new Tuple<Environment, Environment, double>(env1, env2, distance));
            return distance;
        }

        public List<Tuple<Object, String, String, int>> createTableOfStates(Clause cl, Environment env, List<VeilTemplate> programs)
        {
            /* Function Description : Given a clause cl and list of program instances, 
             * corresponding to some verb. This function returns a table of the form 
             *    [Object : Object , State : String, Value : Double]
             */
            List<Tuple<Object, String, String, int>> stateTable = new List<Tuple<Object, String, String, int>>();
            Environment[] endEnvList = new Environment[programs.Count()];

            for (int i = 0; i < programs.Count(); i++)
            {
                //finds last environment for every env in the list
				Environment current = programs [i].env_.makeCopy ();
                foreach (Instruction inst in programs[i].inst_)
                {
                    Instruction instNew = inst.makeCopyAndRevert();
                    current = this.sml.execute(instNew, current);
                }
                endEnvList[i] = current;
            }

            for (int i = 0; i < programs.Count(); i++)
            {
                List<Tuple<String, String>> matchedObjects = this.mapping(programs[i], cl);  //first item is from program
                foreach (Tuple<String, String> tmp in matchedObjects)
                {
                    //tmp.Item2 has to be from cl to continue
                    if (cl.ifExists(tmp.Item2))
                    {
                        Object obj1 = env.findObject(tmp.Item2);
                        //search for tmp.Item1 in endEnvList[i]
                        Object obj2 = endEnvList[i].findObject(tmp.Item1);
                        /* iterate over states of obj and store it in the table if they are 
                           also states of obj1*/
                        List<Tuple<String, String>> newlyFoundStateList = obj2.getState();
                        foreach (Tuple<String, String> single in newlyFoundStateList)
                        {
                            if (obj1.getStateValue(single.Item1).Count() > 0)
                            {
                                //add to the table
                                bool added = false;
                                for (int iter = 0; iter < stateTable.Count(); iter++)
                                {
                                    if (stateTable[iter].Item1.getName().Equals(obj1.getName(), StringComparison.OrdinalIgnoreCase) &&
                                        stateTable[iter].Item2.Equals(single.Item1, StringComparison.OrdinalIgnoreCase) &&
                                        stateTable[iter].Item3.Equals(single.Item2, StringComparison.OrdinalIgnoreCase))
                                    {
                                        stateTable[iter] = new Tuple<Object, string, string, int>(stateTable[iter].Item1, stateTable[iter].Item2, stateTable[iter].Item3, stateTable[iter].Item4 + 1);
                                    }
                                    added = true;
                                }
                                if (!added)
                                {
                                    stateTable.Add(new Tuple<Object, string, string, int>(obj1, single.Item1, single.Item2, 1));
                                }
                            }
                        }
                    }
                }
            }
            return stateTable;
        }

		public List<String[]> initPredicate(Environment env, List<String> objects)
		{
			/* Function Description: Generate the sample space of predicates
			 * which are possible with the given objects and the environment */

			List<String[]> predicates = new List<String[]> ();
			foreach (Object obj in env.objects) 
			{
				List<Tuple<String,String>> stval = obj.getState ();
				foreach (Tuple<String,String> st in stval)
				{
					this.lg.writeToFile (obj.uniqueName+" has state of " + st.Item1);
					if (st.Item1.Equals ("Color"))
						continue;
					if (env.isSastified ("state " + obj.uniqueName + " " + st.Item1) == 0) 
					{
						this.lg.writeToFile ("Also added");
						predicates.Add (new string[3] { "state", obj.uniqueName, st.Item1 });
					}
				}
			}

			foreach (String objName1 in objects) 
			{
				foreach (String objName2 in objects) 
				{
					if (objName1.Equals (objName2) || !env.findObject (objName1).affordances_.Contains ("IsGraspable"))
						continue;
					if (this.ftr.getBaseFormPredicateFreq("(On $ " + objName2 + ")") > 0 &&
						env.isSastified ("On " + objName1 + " " + objName2) == 0)
						predicates.Add (new string[3] { "On", objName1, objName2 });
					if (this.ftr.getBaseFormPredicateFreq("(In $ " + objName2 + ")") > 0 && 
						env.isSastified ("In " + objName1 + " " + objName2) == 0)
						predicates.Add (new string[3] { "In", objName1, objName2 });
				}
			}

			foreach (String objName1 in objects) 
			{
				if (!env.findObject (objName1).affordances_.Contains ("IsGraspable"))
					continue;
				if (this.ftr.getBaseFormPredicateFreq ("(Grasping Robot " + objName1 + ")") > 0 &&
					env.isSastified ("Grasping Robot " + objName1) == 0)
					predicates.Add (new string[3] { "Grasping", "Robot", objName1 });
			}

			return predicates;
		}

		public String[] generateRelevantSpace(Clause cls, Environment env, List<Instruction> insts, List<String> grounded, List<List<String>> plurality)
		{
			/* Function Description: Returns those predicates that contain objects contained referred to by clause cls
			 * or the previous clause. */

			List<double> scores = new List<double> ();
			List<String> objects = grounded; //new List<String> ();
			for (int k=insts.Count()-2; k>=0; k--) //the last one is $ marked
			{
				if (insts [k].getControllerFunction ().StartsWith ("$"))
					break;
				objects = objects.Union (insts [k].returnObject ()).ToList ();
			}

			foreach(List<String> l in plurality)
				objects = objects.Union (l).ToList ();

			List<String> names = cls.lngObj.Select (x => x.getName ()).ToList();
			List<String[]> predicates = initPredicate (env, objects);

			this.lg.writeToFile ("Names = " + String.Join (",", names));

			for (int i=0; i<predicates.Count(); i++) 
			{
				this.lg.writeToFile ("Considering " + String.Join(" ",predicates [i]));
				/* using hacked up primitive score
				 * state objName1 stateName 
				 *  score (max_j {objName1,iterator-np_j} + max_j {stateName,iterator-np_j}) + 1{objName has been used}
				 * rel objName1 objName2
				 *  score (max_j {objName2,iterator-np_j} + max_j {objName2,iterator-np_j}) + (1{objName1 has  been used}+1{objName2 has  been used})/2*/
				double score = 0;// score1 = 0, score2 = 0;
				if (predicates [i] [0].Equals ("state")) 
				{
					/*for (int j=0; j< cls.lngObj.Count(); j++) 
					{
						score1 = Math.Max (score1, );//sensim.GetScore (Global.fetchObjExpand(predicates[i][1]),cls.lngObj[j].getName()));
							score2 = Math.Max (score2, );//sensim.GetScore (Global.fetchObjExpand(predicates[i][2]),cls.lngObj[j].getName()));
					}
					score = score1+score2;*/
					if (objects.Contains (predicates [i] [1])) 
					{
						this.lg.writeToFile ("Gets state score 1<br/>");
						score = score + 1;
					}
					else this.lg.writeToFile ("does not get state score 1<br/>");

					//stateName such as IceCream match the object name IceCream_1
					bool stateValObject = objects.Exists(name => Global.base_(name).Equals(predicates[i][2],StringComparison.OrdinalIgnoreCase));
					//stateName such as Vanilla match the stateName of objects 
					bool stateValStateVal = objects.Exists (delegate(String name)
					{
						Object obj = env.findObject(name);
						return obj.getState().Exists(states => states.Item1.Equals(predicates[i][2]) && states.Item2.Equals("True"));
					});

					if (stateValObject || stateValStateVal || names.Exists (x => x.ToLower().Contains(predicates [i] [2].ToLower())
					                                                        || predicates [i] [2].ToLower().Contains(x.ToLower()))) 
					{
						this.lg.writeToFile ("Gets state score 2<br/>");
						score = score + 1;
					}
					else this.lg.writeToFile ("does not get state score 2<br/>");
				}
				else 
				{
					/*for (int j=0; j< cls.lngObj.Count(); j++) 
					{
						score1 = Math.Max (score1, sensim.GetScore (Global.fetchObjExpand(predicates[i][1]),cls.lngObj[j].getName()));
						score2 = Math.Max (score2, sensim.GetScore (Global.fetchObjExpand(predicates[i][2]),cls.lngObj[j].getName()));
					}
					score = score1 + score2;*/
					if (objects.Contains (predicates [i] [1]) || predicates [i] [1].Equals ("Robot")) 
					{
						this.lg.writeToFile ("Gets rel score 1");
						score = score + 1;
					}
					else this.lg.writeToFile ("does not get rel score 1");
					if (objects.Contains (predicates [i] [2])) 
					{
						this.lg.writeToFile ("Gets rel score 2");
						score = score + 1;
					}
					else this.lg.writeToFile ("does not get rel score 2");
				}
				scores.Add(score);
			}

			//sort the predicate based on score
			for (int i=0; i<predicates.Count(); i++) 
			{
				int index = i;
				for (int j=i+1; j<predicates.Count(); j++) 
				{
					if (scores [j] > scores [index])
						index = j;
				}
				string[] swap = predicates [index];
				double swapsc = scores[index];
				predicates [index] = predicates [i];
				scores [index] = scores [i];
				predicates [i] = swap;
				scores [i] = swapsc;
			}

			for (int k=0; k<objects.Count(); k++)
				this.lg.writeToFile (objects[k]+", ");
			this.lg.writeToFile ("<br/><span style='color:orange'>Top Rank Predicates: "); //pick those with maximum score
			double maxScore = scores[0];
			int pred=0;
			for (pred=0; pred<predicates.Count(); pred++) 
			{
				if (scores [pred] != maxScore)
					break;
				this.lg.writeToFile ("(" + Global.arrayToString (predicates [pred], ' ') + ") cost = " + scores [pred] + " and ");
			}
			this.lg.writeToFile ("</span><br/>");
			return predicates.GetRange(0,pred).Select(predicate => "(" + predicate[0] +" "+predicate[1]+" "+predicate[2]+ ")").ToArray();
		}

        /* Define Inference Algorithms / Baselines below - 
         * Each inference algorithm/baseline accepts a a test environment and some other parameters
         * and returns a tuple of instruction consisting of the ground truth and the inferred sequence.
         * Since ground truth should be known, future revisions should make it a single instruction
         * sequence. */

        public List<Instruction> chance(Tuple<int, int> test, String methodName)
        {
            /* Function Description : Outputs the program based on chance approach
             * Outputs (answer, groundTruth)*/

            List<Instruction> output = new List<Instruction>();
            Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>> utmp = this.obj.getDataInformation(test);
            Tuple<List<Clause>, List<Instruction>> ans = new Tuple<List<Clause>, List<Instruction>>(utmp.Item2.returnEventClause(), utmp.Item3);
            List<Clause> cls = ans.Item1;

            lg.writeToFile("<div> <button onclick='show(this)'>Using Method : " + methodName + " </button> <div style='display:none;'><h3>Clausal Decomposition</h3>");
            foreach (Clause cl in cls)
                cl.display(this.lg);

            foreach (Clause cl in cls)
            {
                String verbName = cl.verb.getName();
                bool added = false;
                foreach (VerbProgram v in this.veil)
                {
                    if (String.Equals(v.getName(), verbName, StringComparison.OrdinalIgnoreCase)) //verb exists
                    {
                        added = true;
                        List<VeilTemplate> programs = v.getProgram();

                        #region programInstance Selection
                        /* select the one with mininimm distance value where the distance is computed using different methods */
                        this.lg.writeToFile("<span style='color:blue'> Possible Options : " + programs.Count() + "</span><br/>");
                        int minIndex = this.rnd.Next(programs.Count);
                        VeilTemplate minEntry = programs[minIndex];
                        #endregion

                        #region debugOnly
                        String data = "<div> <button onclick='show(this)'> ShowDebugInformation </button> <div style='display:none;'> Possible Option " + programs.Count() + "<br/> ";
                        for (int iter = 0; iter < programs.Count(); iter++)
                        {
                            data = data + "<span style='font-style: italic; '> Program Instance : " + iter + ", File_Loc " + v.fileNameString(iter) + ", Distance" + 1 + "</span><br/>";
                        }
                        data = data + "</div></div>";
                        lg.writeToFile(data);
                        #endregion

                        /* Instantitate the Instruction Set using cls and tmp.Item1*/
                        lg.writeToFile("<span>Verb Name -  " + v.getName() + "  File Loc " + v.fileNameString(minIndex) + "</span><br/><div> Instruction Set <br/>");

                        foreach (Instruction inst in minEntry.inst_)
                            inst.display(this.lg);

                        lg.writeToFile("</div><div> After Instantiation<br/> Using Clause <br/>");
                        cl.display(this.lg);

                        lg.writeToFile("To instantiate instruction set<br/>");
                        minEntry.cls_.display(this.lg);
                        lg.writeToFile("</div><br/><br/>");

                        List<Instruction> instantiated = null;
                        instantiated = this.resetInstantiate(minEntry);

                        foreach (Instruction inst in instantiated)
                            inst.display(this.lg);

                        foreach (Instruction inst in instantiated)
                        {
                            /*Execute the instruction and update the environment*/
                            lg.writeToFile("<li>Executing Instruction");
                            inst.display(lg);
                            lg.writeToFile("</li>");
                            output.Add(inst);
                        }
                        lg.writeToFile("Execution Over<br/><br/>");
                        break;
                    }
                }
                if (!added)
                {
                    lg.writeToErrFile("Could not find/learn definition for the verb " + verbName);
                    lg.writeToFile("Could not find/learn definition for the verb " + verbName);
                }
            }

            this.lg.writeToFile("</div></div><div> Final Output <br/><br/><table>");
            int count = Math.Max(output.Count(), ans.Item2.Count());
            for (int i = 0; i < count; i++)
            {
                this.lg.writeToFile("<tr><td>");
                if (i < output.Count())
                    output[i].display(this.lg);
                this.lg.writeToFile("</td><td>");
                if (i < ans.Item2.Count())
                    ans.Item2[i].display(this.lg);
                this.lg.writeToFile("</td></tr>");
            }
            this.lg.writeToFile("</table></div><br/><br/>");

            return output;
        }

        public List<Instruction> templateBasedBaselines(Tuple<int, int> test)
        {
            /* Function Description : Following is a baseline algorithm based partially on 
             * the workd - 'Grounding Spatial Relations for Human-Robot Interaction by 
             * Guadarrama et al. IROS'. The work focusses on manually defined templates and we
             * extend it by taking into account many-many mapping. However, the main paper focussed
             * on grounding of language-objects while in our present work we will just have a 
             * predefined mapping to objects in the real environment. These templates are defined
             * independently of the actual environment. Since these templates do not have any predefined
             * objects hence we will use a different version of instantiation for this algorithm */

            Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>> utmp = this.obj.getDataInformation(test);
            List<Instruction> output = new List<Instruction>();

            List<Clause> cls = utmp.Item2.returnEventClause();
            Environment iterator = this.envList[test.Item1 - 1].makeCopy();

            foreach (Clause cl in cls) //iterate over each clause
            {
                String verbName = cl.verb.getName();
                List<Instruction> found = new List<Instruction>();
                foreach (Template tm in this.ftr.templates)
                {
                    if (tm.isSameVerb(verbName))
                    {
                        found = tm.instantiate(cl, iterator);
                        break;
                    }
                }

                //execute and update iterator
                foreach (Instruction inst in found)
                {
                    iterator = this.sml.execute(inst, iterator);
                    output.Add(inst);
                }
            }

            this.lg.writeToFile("Final Output <br/><br/><table>");
            int count = Math.Max(output.Count(), utmp.Item3.Count());
            for (int i = 0; i < count; i++)
            {
                this.lg.writeToFile("<tr><td>");
                if (i < output.Count())
                    output[i].display(this.lg);
                this.lg.writeToFile("</td><td>");
                if (i < utmp.Item3.Count())
                    utmp.Item3[i].display(this.lg);
                this.lg.writeToFile("</td></tr>");
            }
            this.lg.writeToFile("</table><br/><br/>");

            return output;
        }

        public List<Instruction> treeExploration(Tuple<int, int> test)
        {
            /* Function Description : Uses tree-expansion algorithm to expand the tree of instructions and
             * the pick up the node which has maximum resemblance to the given clause and can be easily
             * executed. */
            Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>> utmp = this.obj.getDataInformation(test);
            List<Instruction> output = new List<Instruction>();

            List<Clause> cls = utmp.Item2.returnEventClause();
            Environment iterator = this.envList[test.Item1 - 1].makeCopy();

            foreach (Clause cl in cls) //iterate over each clause
            {
                List<String> clsW = new List<String>();
                clsW.Add(cl.verb.getName());
                List<SyntacticTree> sns = cl.returnNounList();
                foreach (SyntacticTree sn in sns)
                    clsW.Add(sn.getName());

                InstructionTree root = new InstructionTree(iterator);
				double[] weights_opt = null;
                List<Instruction> receiv = InstructionTree.findBestAndExpand(root,weights_opt, clsW);
                foreach (Instruction inst in receiv)
                    output.Add(inst);
                root.free();
            }

            this.lg.writeToFile("Final Output <br/><br/><table>");
            int count = Math.Max(output.Count(), utmp.Item3.Count());
            for (int i = 0; i < count; i++)
            {
                this.lg.writeToFile("<tr><td>");
                if (i < output.Count())
                    output[i].display(this.lg);
                this.lg.writeToFile("</td><td>");
                if (i < utmp.Item3.Count())
                    utmp.Item3[i].display(this.lg);
                this.lg.writeToFile("</td></tr>");
            }
            this.lg.writeToFile("</table><br/><br/>");

            return output;
        }
		
        public List<Instruction> optimumWithLatentNodesAndTrim(Tuple<int, int> test, Environment start, Tester tester, int topN, double[] weights)
        {
            /* Function Description : This algorithm implements the forward-backward inference algorithm
             * for the assumed linear CRF. The algorithm works as - 
             * 
             * It finds sample space environments at each step of the CRF chain for the next step and uses the
             * the sample space of the previous step to do the forward inference.
             * The main agenda is that the space of environment at level k will be less than O(|T|^k) where
             * |T| is the average sample space of instructions at each level. The argument for this sparsity
             * assumptions is that different ways of doing anything will focus on a cover of objects which will
             * be much smaller than space of all objects.
             * 
             * Complexity : 
             * 
             * |T|  : average number of instruction sequence per clause
             * |E|  : space of all environments
             * |ER| : average space of all reduced environments
             * k    : length of sequence = number of clauses in the environment
             * 
             * Brute Force Search                       -  O(|T|^k)
             * Forward-Backward on all environments     -  O(k|E||T|)
             * Forward-Backward on reduced environment  -  O(k|ER||T|)
             */


            Tuple<Tuple<int, int>, Clause, List<Instruction>, List<Clause>> testData = tester.obj.getDataInformation(test);
            List<Clause> cls = testData.Item2.returnEventClause();

            if (topN == -1)
                tester.lg.writeToFile("<div> <button onclick='show(this)'>Using Method Optimum-Algorithm </button> <div style='display:none;'><h3>Clausal Decomposition</h3>");
            else tester.lg.writeToFile("<div> <button onclick='show(this)'>Using Method Top" + topN + "Algorithm </button> <div style='display:none;'><h3>Clausal Decomposition</h3>");

            foreach (Clause cl in cls)
                cl.display(tester.lg);

            /* Compute the optimal instruction sequence by forward recursion 
             *
             * Alpha(E,k) = min_{E' \in sampleSpace[k]} min_{I \in T, Phi(E',I_l:I) = E } { Psi_{kl} + Psi_{kl}' + Psi_{k} + Psi_{k}' + Alpha(E',k-1) }
             *
             * alpha[e,k] data structure will store both the optimum instruction and the optimum cost
             * where the optimal instruction is the one with minimum cost starting with E0 and ending at level k in chain
             * with the environment e
             */

            List<Tuple<Environment, List<Instruction>, double>>[] alpha = new List<Tuple<Environment, List<Instruction>, double>>[cls.Count + 1];

            for (int i = 0; i < cls.Count; i++)
            {
                if (i == 0)
                {
                    alpha[0] = new List<Tuple<Environment, List<Instruction>, double>>();
                    alpha[0].Add(new Tuple<Environment, List<Instruction>, double>(start, new List<Instruction>(), 0));  //base case (StartingEnv, {empty-sequence},0 cost)
                }
                alpha[i + 1] = new List<Tuple<Environment, List<Instruction>, double>>(); //after this line, alpha[i], alpha[i+1] are defined with former already computed

                String verbName = cls[i].verb.getName();

                /* we have to define alpha(E,i) for all E in sampleSpace[i] assuming
                 * alpha(E',j) is known for all reachable E' and j < i. We also assume 
                 * we know the sampleSpace at all level j < i */

                foreach (Tuple<Environment, List<Instruction>, double> seen in alpha[i]) //now E = env
                {
                    Environment env = seen.Item1;
                    foreach (VerbProgram v in tester.veil)
                    {
                        if (String.Equals(v.getName(), verbName, StringComparison.OrdinalIgnoreCase)) //verb exists
                        {
                            List<VeilTemplate> programs = v.getProgram();
                            List<Tuple<Object, String, String, int>> tableOfStates = null; //used by accumulated score

                            /* Compute the variability table of the form 
                                * [ Object : State : Value ]
                                * where Object : is in Clause, State are its state and Value is the value of the state*/
                            tableOfStates = this.createTableOfStates(cls[i], env, programs);

                            for (int t = 0; t < programs.Count(); t++) //Step : Iterate over all program instances
                            {
                                /* For each program instance (T) we compute the score given by - 
                                 * 
                                 * interpolation or latent node score (T) + score of the non-latent node (T) + Beta(E',i+1)
                                 * where E' = execute(E, interpolated-instantianted program)
                                 */

                                for (int trim = 0; trim <= programs[t].inst_.Count(); trim++) // Step :  Trimming
                                {
                                    double score_interpolate = 0, score_core = 0, trim_score = weights[this.ftr.numFeature - 4] * trim * trim;
                                    VeilTemplate tmp = this.trimItDown(programs[t], trim);
                                    Tuple<double, List<Tuple<String, String>>> result = null;
                                    double cost = 0;

                                    // Step : Find the interpolation
                                    List<Tuple<string, string>> matching = this.mapping(tmp, cls[i]);
                                    //List<Instruction> interpolation = this.symp.writeFiles(stackOfEnv.Last(), tmp.Item3, matching);
									Tuple<List<Instruction>, String> resultInterpol = null;//tester.symp.satisfyConstraints(env, new List<Instruction>(), tmp.env_, tmp.inst_, matching);
                                    List<Instruction> interpolation = resultInterpol.Item1;

                                    // Step : Change the environment
                                    Environment iterator = env.makeCopy();
                                    foreach (Instruction inst in interpolation)
                                        iterator = tester.sml.execute(inst, iterator);

                                    // Step : compute the score
                                    score_interpolate = this.ftr.giveInterpolationScore(interpolation, weights);

                                    // Step : Compute the score of the interpolation
                                    result = this.ftr.getAccumulatedScore(tmp, cls[i], iterator, tableOfStates, t.ToString(), this); //compute score here
                                    score_core = result.Item1;

                                    int interPolLength = interpolation.Count();

                                    List<Instruction> core = this.instantiate(tmp, cls[i], null);
                                    cost = score_interpolate + score_core + trim_score;

                                    List<Instruction> total = interpolation;
                                    foreach (Instruction inst in core)
                                    {
                                        iterator = tester.sml.execute(inst, iterator);
                                        total.Add(inst);
                                    }

                                    cost = cost + seen.Item3; //adding the previously seen cost

                                    /* we have generated a step where the sequence I_interpol : I_core 
                                     * given the environment env gives the environment iterator. We now
                                     * see if the environment iterator appears in alpha[i+1]. If not then
                                     * we add its entry. If yes then we see if the cost of this one is lower
                                     * and according replace */

                                    List<Instruction> entireInstructionSeq = seen.Item2.ToList();
                                    foreach (Instruction inst in total)
                                    {
                                        entireInstructionSeq.Add(inst);
                                    }

                                    bool replace = false;
                                    int oldEntry = -1;
                                    for (int iter = 0; iter < alpha[i + 1].Count(); iter++)
                                    {
                                        Tuple<Environment, List<Instruction>, double> newEntry = alpha[i + 1][iter];
                                        if (newEntry.Item1.distance(iterator) == 0)
                                        {
                                            oldEntry = iter;
                                            if (cost < newEntry.Item3)
                                            {
                                                replace = true;
                                                break; //there is atmost one entry with same environment
                                            }
                                        }
                                    }

                                    if (oldEntry == -1) //no entry exist
                                        alpha[i + 1].Add(new Tuple<Environment, List<Instruction>, double>(iterator, entireInstructionSeq, cost));
                                    else if (replace)
                                        alpha[i + 1][oldEntry] = new Tuple<Environment, List<Instruction>, double>(iterator, entireInstructionSeq, cost);
                                }
                            }
                        }
                    }
                }

                /* If a given verb does not have any templates then alpha[i+1] will be
                 * empty in which case we simply copy alpha[i] to alpha[i+1] */
                if (alpha[i + 1].Count() == 0)
                    alpha[i + 1] = alpha[i];
                else alpha[i].Clear(); /* Whereto the climber upward turns his face. But when he once attains the upmost round, He then unto the ladder turns his back - Brutus [Julius Caesar] */


                /* Churning
                 * The time complexity of O(kEt) is significant since each of the t templates
                 * takes sufficient amount of time. I propose to use a greedy churning strategy
                 * where we only take the top N choices. This compromises optimality guarantee
                 * at the cost of speed. If N==-1 then the algorithm will use all the entry
                 * else it will use the top choices.
                 */

                if (topN != -1 && alpha[i + 1].Count() > topN)
                {
                    //keep only the topN choices in alpha[i+1]
                    List<Tuple<Environment, List<Instruction>, double>> best = new List<Tuple<Environment, List<Instruction>, double>>();
                    List<int> bestIndex = new List<int>();

                    for (int iter = 0; iter < alpha[i + 1].Count(); iter++)
                    {
                        if (iter < topN)
                        {
                            //insert at the proper position
                            if (iter == 0)
                            {
                                bestIndex.Add(0);
                            }
                            else
                            {
                                bool added = false;
                                for (int j = 0; j < iter; j++)
                                {
                                    if (alpha[i + 1][iter].Item3 < alpha[i + 1][bestIndex[j]].Item3)
                                    {
                                        added = true;
                                        bestIndex.Insert(j, iter);
                                        break;
                                    }
                                }

                                if (!added)
                                    bestIndex.Add(iter);
                            }
                        }
                        else if (alpha[i + 1][iter].Item3 < alpha[i + 1][bestIndex[topN - 1]].Item3)
                        {
                            //insert at the proper position
                            for (int j = 0; j < topN; j++)
                            {
                                if (alpha[i + 1][iter].Item3 < alpha[i + 1][bestIndex[j]].Item3)
                                {
                                    bestIndex.Insert(j, iter);
                                    break;
                                }
                            }
                        }
                    }

                    //use bestIndex to store these choices in best
                    for (int iter = 0; iter < topN; iter++)
                        best.Add(alpha[i + 1][bestIndex[iter]]);
                    alpha[i + 1] = best;
                }

                #region debugPurposeOnly
                /*List<Tuple<String, String, int>> val = new List<Tuple<String, String, int>>();
                foreach(Tuple<Environment, List<Instruction>, double> entry in alpha[i+1])
                {
                    foreach (Object obj in entry.Item1.giveObjList())
                    {
                        foreach (Tuple<String, String> t in obj.getState())
                        {
                            bool exist = false;
                            for (int z = 0; z < val.Count(); z++)
                            {
                                Tuple<String, String, int> e = val[z];
                                if (e.Item1.Equals(obj.getName() + t.Item1) && e.Item2.Equals(t.Item2))
                                {
                                    exist = true;
                                    val[z] = new Tuple<string, string, int>(e.Item1, e.Item2, e.Item3 + 1);
                                }
                            }

                            if (!exist)
                            {
                                val.Add(new Tuple<string, string, int>(obj.getName()+t.Item1,t.Item2,1));
                            }
                        }
                    }
                }*/
                #endregion
            }

            //find optimal instruction from alpha[cls.count]

            List<Instruction> output = null;
            double optCost = Double.PositiveInfinity;
            if (cls.Count() == 0)
                output = new List<Instruction>();
            else
            {
                foreach (Tuple<Environment, List<Instruction>, double> done in alpha[cls.Count])
                {
                    if (done.Item3 < optCost)
                    {
                        output = done.Item2;
                        optCost = done.Item3;
                    }
                }
            }

            #region fancyOutput
            tester.lg.writeToFile("</div></div><div> Final Output Cost = (" + optCost + ") <br/><br/><table>");

            int count = Math.Max(output.Count(), testData.Item3.Count());

            for (int i = 0; i < count; i++)
            {
                tester.lg.writeToFile("<tr><td>");
                if (i < output.Count())
                {
                    output[i].display(tester.lg);
                }
                tester.lg.writeToFile("</td><td>");
                if (i < testData.Item3.Count())
                    testData.Item3[i].display(tester.lg);
                tester.lg.writeToFile("</td></tr>");
            }
            tester.lg.writeToFile("</table></div><br/><br/>");
            #endregion

            return output;
        }

		public List<Instruction> rss2015(Clause cls, Environment env, Tester tester, Dictionary<String, Double> weights, List<object> param)
        {
            /* Function Description : The main algorithm for grounding the clause-tree cls given the starting environment env. */
			this.oldvalue = null;
			String name = "Main Model with VEIL template " + ((bool)param[0]).ToString () + " Generative Templates " + 
					      ((bool)param[1]).ToString ()+" Storing Templates "+ ((bool)param[2]).ToString ();
			tester.lg.writeToFile ("<div> <button onclick='show(this)'> " + name + "</button> <div style='display:none;'><h3>Clausal Decomposition</h3>");
            List<Clause> evnCl = cls.returnEventClause();
            foreach (Clause c in evnCl)
                tester.lg.writeToFile(c.getClauseDscp()+"; ");
            
            tester.lg.writeToFile("<br/>");

            List<Tuple<Clause, List<Tuple<Environment, List<Instruction>, double>>>> alpha = new List<Tuple<Clause, List<Tuple<Environment, List<Instruction>, double>>>>();

            List<Clause> visited = new List<Clause>(); //A node is visited when it has been considered for score evaluation
            List<Clause> cover = new List<Clause>();   /* Cover is a set clause nodes which have not been visited 
                                                       * but all their parents have been visited */
            List<Instruction> output = null;
            double maxScoreLeaf = Double.NegativeInfinity;
            cover.Add(cls); //Since parent of cls is null

            List<Tuple<Environment, List<Instruction>, double>> singletonRoot = new List<Tuple<Environment, List<Instruction>, double>>();
            singletonRoot.Add(new Tuple<Environment, List<Instruction>, double>(env, new List<Instruction>(), 1));//this was 0 earlier
            alpha.Add(new Tuple<Clause, List<Tuple<Environment, List<Instruction>, double>>>(null, singletonRoot));

            while (cover.Count() != 0)
            {
                Clause iterator = cover[0];
				if(iterator.isCondition)
					Console.WriteLine("Working on a condition "+iterator.conditionName);
				else Console.WriteLine("Working on a fresh clause "+iterator.verb.getName());
                cover.RemoveAt(0);

                /* Find reachable entries
                 * - as its in the cover, all its parents have been visited
                 * - find the entries of the parents in the alpha list and trim the non-reachable ones
                 *   ex: if there is an if-condition between the parent and this cls then trim the entries
                 *       according to the condition, the environment in the entry and position of the iterator node
                 *       ex:- if the iterator node is on the true side and if condition is true in the environment then
                 *       keep the entry else trim*/

                List<Tuple<Environment, List<Instruction>, double>> entryThisClause = new List<Tuple<Environment, List<Instruction>, double>>();

                foreach (Tuple<Clause, List<Tuple<Environment, List<Instruction>, double>>> entries in alpha)
                {
                    if (iterator.parent.Contains(entries.Item1) || (iterator.parent.Count() == 0 && entries.Item1 == null))
                    {
                        foreach (Tuple<Environment, List<Instruction>, double> history in entries.Item2)
                        {
                            //if the parent is a condition then make sure that this branch is reachable
                            bool reachable = true;
                            if (entries.Item1 != null && entries.Item1.isCondition)
                                reachable = history.Item1.isConditionSatisfied(entries.Item1.condition);

                            if (reachable) //only if the clause is reachable can you do anything with it
                            {
								Tuple<List<Instruction>, int, Double> res = null; 
								res = this.rss2015NodePredicates (iterator, history, tester, entryThisClause, weights, param);
                                if (iterator.children == null || iterator.children.Count() == 0)
                                {
                                    if (res.Item3 > maxScoreLeaf)
                                    {
                                        output = res.Item1;
										maxScoreLeaf = res.Item3;
                                    }
                                }
							}
                        }
                    }
                }

                #region keep_top_k_options
                entryThisClause.Sort((a, b) => b.Item3.CompareTo(a.Item3));
                if(entryThisClause.Count() >= 1)
                    entryThisClause.RemoveRange(1, entryThisClause.Count() - 1);
                #endregion

                //Add iterator to the list of visited nodes and update the alpha list
                visited.Add(iterator);
                alpha.Add(new Tuple<Clause, List<Tuple<Environment, List<Instruction>, double>>>(iterator, entryThisClause));

                // Add those children of the iterator to the cover whose all parents have been visited
                foreach (Clause child in iterator.children)
                {
                    bool unvisParentExist = false;
                    foreach (Clause parent in child.parent)
                    {
                        if (!visited.Contains(parent))
                            unvisParentExist = true;
                    }
                    if (!unvisParentExist)
                        cover.Add(child);
                }
            }
            // we output the instruction sequence = argmin_{[i]} { [ (c,e,[i],double) \in alpha, c is a leaf}
            tester.lg.writeToFile("</div></div>");
            if(output == null)
				return new List<Instruction>();
            return output;
        }


		private Tuple<List<Instruction>, int, Double> rss2015NodeInstruction(Clause iterator, Tuple<Environment, List<Instruction>, double> history,
		                                                     Tester tester, List<Tuple<Environment, List<Instruction>, double>> entryThisClause,
		                                                     Dictionary<String, Double> weights, bool generate)
        {
            /* Function Description: For a given node, the history (given environment, instruction so far, score so far) 
             * this algorithm updates the entryThisClause vector by performing inference steps on this clause node.
             * The algorithm also return the best score and corresponding instruction sequence. */

            bool unseen = true; //verb maybe unseen in the data-set
            Environment envTest = history.Item1;
            List<Instruction> output = null;
            double maxScoreLeaf = Double.NegativeInfinity;
			int interpolateLen = -1;

            if (!iterator.isCondition) //moves are applied only on eventive clauses
            {
				tester.lg.writeToFile("<div> <button onclick='show(this)'>Clause - "+iterator.verb.getName()+"</button> <div style='display:none;'>");
                #region apply_inference_steps
                /* - infern I^pre, I and I^post 
                 *  - infer I from the dataset D
                 *  - iterate over each dataset D_iterator = { {(c,i,e,z,\xi) \in D such that v(C)=v(iterator) }
                 */

                List<VerbProgram> veil = tester.veil;
                foreach (VerbProgram v in veil)
                {
                    if (v.getName().Equals(iterator.verb.getName(), StringComparison.OrdinalIgnoreCase))
                    {
                        unseen = false; //its seen in th data-set
                        List<VeilTemplate> vtList = v.getProgram();

                        int count = 0;
                        foreach (VeilTemplate vt in vtList)
                        {

                            /* For each vt = (c,i,e,z\xi)
                             * - do trimming over the length of i
                             * - do instantiation of the remaining
                             * - infer i^pre and i^post
                             * - compute the cost
                             * - add entry to the alpha list
                             * */
                            List<Instruction> insts = vt.inst_;
                            for (int trim = 0; trim < 1/*insts.Count() + 1*/; trim++)
                            {
                                /* Consider insts[0:trim] where - insts[0:0] = No-Op and 
                                 * insts[0:insts.Count()] means the entire sequence */
                                VeilTemplate tmp = this.trimItDown(vt, trim); //trimming
								Tuple<int[], double> mappingResult = this.map.mappingInstruction(tmp, iterator, envTest, history.Item2, weights);
								if(mappingResult ==null)
									continue;
                                int[] mapping = mappingResult.Item1;
                                List<Instruction> instant = this.instantiation(tmp, mapping, envTest);

                                /* We already have C_i that is the iterator, we also know the starting 
                                 * environment envTest, we now need to infer the I^pre and I^post. 
                                 * For the moment I am not computing I^post but this shall be remedied
                                 * in the future version. Presently computing I^pre using hard-constraints only */

                                /* Contains different contraints that shall acts as the goal for a Symbolic Planner.*/
                                List<String> constraints = new List<String>();
                                String hardConstraints = "";
                                Environment iterEnv = envTest.makeCopy();
                                foreach (Instruction inst in instant)
                                {
                                    Tuple<double, string, string> res = tester.sml.satSyntConstraints(inst, iterEnv);
                                    if (res.Item3 == null) //this instruction can never be satisfied
                                    {
                                        hardConstraints = null;
                                        break;
                                    }
                                    if (res.Item3.Length > 0)
									{
										if(hardConstraints.Length==0)
											hardConstraints=res.Item3;
                                        else hardConstraints = hardConstraints + "^" + res.Item3;
									}
                                    iterEnv = tester.sml.execute(inst, iterEnv, true); //forced execution
                                }

                                if (hardConstraints == null)//this instruction sequence is hopelessly irrepairable hence continue
                                    continue;

								hardConstraints = string.Join("^",hardConstraints.Split(new char[]{'^'}).Distinct().ToList());
                                constraints.Add(hardConstraints);

                                foreach (String cstr in constraints)
                                {
                                    /* For each constraint, find the instruction sequence that satisfies it
                                     * Each constraint is of type - predicate^predicate^.... where these
                                     * predicates need to be satisfied */

									List<Instruction> iPre = tester.symp.satisfyConstraints(envTest, cstr);
									if(iPre == null)
										continue;
                                    List<Instruction> total = iPre.ToList(); //entire sequence corresponding to iterator
                                    foreach (Instruction itmp in instant)
                                        total.Add(itmp);

                                    /* Feature computation stage
                                     * - Given envTest, instant, iPre we compute the feature in order as -
                                     *   1. Mapping Cost (which takes into account 5 features)
                                     *   2. Instruction prior
                                     *   3. Verb-Correlation Score
                                     *   4. Description Length
                                     *   5. Trimming Cost
                                     */

									double totalScore = history.Item3, mappingCost= 0,iprInter=0,ipr=0,vccInter=0,vcc=0,dscp=0,dscpInter=0,trimCost=0;
                                    mappingCost = mappingResult.Item2; //Mapping-Cost
									iprInter = weights["w_ipr"] * iPre.Aggregate(0.0, (sum, n) => sum + this.ftr.getInstructionPrior(n)) / (iPre.Count() + Constants.epsilon);
                                    ipr = weights["w_ipr"] * instant.Aggregate(0.0, (sum, n) => sum + this.ftr.getInstructionPrior(n)) / (instant.Count() + Constants.epsilon);
                                    vcc = weights["w_vc"] * this.ftr.getAvgVerbCorrelation(iPre);
                                    vccInter = weights["w_vc"] * this.ftr.getAvgVerbCorrelation(instant);
                                    dscpInter = weights["w_dscp"] * iPre.Aggregate(0.0, (sum, n) => sum + n.norm());
                                    dscp = weights["w_dscp"] * instant.Aggregate(0.0, (sum, n) => sum + n.norm());
                                    trimCost = weights["w_trim"] * trim * trim;
									totalScore += mappingCost + iprInter + ipr + vcc + vccInter + dscpInter + dscp + trimCost;

									tester.lg.writeToFile("Template Count ["+count+"]<ul>"+
									                      "<li><b>Constraints:</b> "+ cstr+"</li>"+
									                      "<li><b>Length of Interpolation:</b> "+iPre.Count()+"</li>"+
									                      "<li><b>History:</b> "+history.Item3+"</li>"+
									                      "<li><b>Mapping Cost:</b> "+mappingCost+"</li>"+
									                      "<li><b>IPR InterPol:</b> "+iprInter+"</li>"+
									                      "<li><b>DSCP InterPol:</b> "+dscpInter+"</li>"+
									                      "<li><b>VCC InterPol:</b> "+vccInter+"</li>"+
									                      "<li><b>IPR:</b> "+ipr+"</li>"+
									                      "<li><b>DSCP:</b> "+dscp+"</li>"+
									                      "<li><b>VCC:</b> "+vcc+"</li>"+
									                      "<li><b>Trim:</b> "+trimCost+"</li>"+
									                      "<li><b>Total Energy</b> = "+totalScore+"</li></ul>");

									List<Instruction> entire = history.Item2.ToList();
									foreach(Instruction inst in total)
										entire.Add(inst);

									if (iterator.children == null || iterator.children.Count() == 0)//iterator is a leaf
                                    {
                                        if (totalScore > maxScoreLeaf)
                                        {
											output = entire;
											interpolateLen = iPre.Count(); 
                                            maxScoreLeaf = totalScore;
                                        }
									}

									Environment iterEnv_ = tester.sml.executeList(total, envTest);
									Instruction marker = new Instruction ();
									marker.setNameDescription ("$Verb "+iterator.verb.getName()+" Count = "+count,new List<String>());
									entire.Add(marker);
                                    entryThisClause.Add(new Tuple<Environment, List<Instruction>, double>(iterEnv_, entire, totalScore));
                                }
                            }
							count++;
                        }
                    }
                }
				tester.lg.writeToFile("</div></div>");
                #endregion
            }

			if (unseen || iterator.isCondition)//Copy the parent to this node
			{
				Instruction marker = new Instruction ();
				if (unseen)
					marker.setNameDescription ("$Unseen Verb", new List<String> ());
				else if (iterator.isCondition)
					marker.setNameDescription ("$Conditional", new List<String> ());
				history.Item2.Add (marker);
			}
                entryThisClause.Add(history);

            if (output == null)
            {
                output = history.Item2;
                maxScoreLeaf = history.Item3;
            }
			return new Tuple<List<Instruction>, int, double> (output, interpolateLen, maxScoreLeaf);
        }

		private List<Tuple<String,double>> bottomUpGenTemplate(Clause iterator, Tuple<Environment, List<Instruction>, double> history, Tester tester,
		                                                       double[,] leTestCorrMatrix, List<String> grounded, List<List<String>> plurality, 
		                                                       Dictionary<String, Double> weights)
		{
			/* Function Description: Gen-Template Algorithm which generates new samples. The algorithm is as follows:-
			 * 1. Find a small space of predicates that consists of relevant object
			 * 2. Find factor score of each atomic predicates
			 * 3. Pick the top K and consider their combination
			 * 4. If these combinations do not increase the factor score then stop else repeat the 2-4 cycle */

			Environment envTest = history.Item1;
			List<Tuple<String,Double>> predScoreTable = new List<Tuple<string, double>> ();
			VerbProgram v = tester.veil.Find(veil_ => veil_.getName().Equals(iterator.verb.getName(), StringComparison.OrdinalIgnoreCase));

			String[] sampleSpace = this.generateRelevantSpace (iterator, history.Item1, history.Item2, grounded, plurality);
			List<String> queue = new List<String>();

			for (int i=0; i<sampleSpace.Length; i++)
				queue.Add (sampleSpace[i]);

			bool genPivotNotFound = true;
			double genPivotScore = Double.NegativeInfinity;

			while(genPivotNotFound)
			{
				if(queue.Count() == 0)
				{
					genPivotNotFound=false; 
					break;
				}

				List<Tuple<String,Double>> newlyAdded = new List<Tuple<string, double>> ();
				#region find_factor_scores_of_every_sample
				genPivotNotFound = false;
				foreach(String constraint in queue)
				{
					/* Feature computation stage
	                 * - Given envTest, iterator, set of predicates {q} and resultant instruction sequence {i}  
	                 *   1. Mapping Cost = LE cost + EE cost (at the moment)
	                 *   2. Instruction prior
	                 *   3. Verb-Correlation Score
	                 *   4. Description Length
	                 *   5. Trimming Cost 
	                 *   6. Avg. Frequency of predicate skeletal {q} */

					double mapCost = 0, dscpCost = 0, predSkeletalPrior = 0, predTotalPrior = 0, le = 0, leRecall = 0,
					       endState=0, bias = 0, trans = 0, argTrans = 0;

					List<String> objectCover = Global.getObjects(constraint, history.Item1);
					String lelog = "";
					foreach(String objName in objectCover)
					{
						int j = envTest.objects.FindIndex(x => x.uniqueName.Equals(objName));
						double lePerObject = 0;
						for(int i=0; i<leTestCorrMatrix.GetLength(0);i++) 
							lePerObject = Math.Max(lePerObject,leTestCorrMatrix[i,j]);
						le = le + lePerObject;
						lelog = lelog + objName + " -> " + lePerObject + "; ";
					}

					for(int lang=0; lang < leTestCorrMatrix.GetLength(0); lang++)
					{
						double max = Double.NegativeInfinity;
						foreach(String objName in objectCover)
							max = Math.Max(max, leTestCorrMatrix[lang, envTest.objects.FindIndex(x=>x.uniqueName.Equals(objName))]);
						if (max < 0.85)
							max = 0;
						leRecall = leRecall + max;
					}

					leRecall = weights["w_lerecall"]*leRecall/(leTestCorrMatrix.GetLength(0)+Constants.epsilon);
					lelog = lelog + " divide "+le+" with "+objectCover.Count();
					mapCost= weights["w_le"]*le/ (objectCover.Count() + Constants.epsilon); //the EE cost is 0 as there is no reference
					String[] splitter = constraint.Split(new char[]{'^'});
					dscpCost= weights["w_dscp"] * splitter.Length;//generatedInst.Aggregate(0.0, (sum, n) => sum + n.norm());

					if(v!=null)
						predSkeletalPrior = weights["w_prior"]*splitter.Aggregate(0.0,(sum,cstr_) => sum + v.fetchFrequency(cstr_))/(splitter.Length*v.totalFrequency() + Constants.epsilon);
					predTotalPrior = weights["w_argprior"]*splitter.Aggregate(0.0,(sum,cstr_) => sum + this.ftr.getPredicateFreq(cstr_))/(splitter.Length*this.ftr.zPredFreq + Constants.epsilon);
					String endStateLog = "Not-End";
					if (iterator.children == null || iterator.children.Count() == 0)
					{
						endStateLog="";
						endState = weights["w_end"]*this.ftr.getEndStateProbability(constraint);
					}

					Tuple<double, String> relres = this.ftr.fetchRelationshipFeature(iterator, plurality, constraint);
					double relfeature = weights["w_rel"]*relres.Item1;
					bias = 0;//weights["w_bias"];
					trans = weights["w_trans"]*this.ftr.fetchTransitionProbability(constraint, this.oldvalue);
					argTrans = weights["w_argtrans"]*this.ftr.fetchArgTransitionProbability(constraint, this.oldvalue);

					double totalScore = history.Item3*Math.Exp(mapCost + leRecall + dscpCost + predSkeletalPrior + predTotalPrior + 
					                                           relfeature + endState + bias + trans + argTrans);

					tester.lg.setLowPriority();
					tester.lg.writeToFile("Generated Template "+predScoreTable.Count()+"<ul>"+
					                      "<li><b>Constraint</b> "+constraint+"</li></ul>"+
										  "<ul><li><b>Mapping Score</b> "+mapCost+" [Ge LE cost "+ lelog +"]</li>"+
					                      "<li><b>Language Recall</b> "+leRecall+" </li>"+
					                      "<li><b>Description Length</b> "+dscpCost+"</li>"+
					                      "<li><b>Sentence Similarity</b> 0</li>"+
					                      "<li><b>Predicate Skeletal Prior</b> "+predSkeletalPrior+"</li>"+
					                      "<li><b>Predicate Total Prior</b> "+predTotalPrior+"</li>"+
					                      "<li><b>Relationship feature</b> "+relfeature+"  ["+relres.Item2+"] </li>"+
					                      "<li><b>End State</b> "+endState+" ["+endStateLog+"]</li>"+
					                      "<li><b>Bias</b> "+bias+"</li>"+
					                      "<li><b>Transition Prob.</b> "+trans+"</li>"+
					                      "<li><b>Arg Transition Prob.</b> "+argTrans+"</li>"+
					                      "<li><b>Total Score </b> = "+totalScore+"</li></ul>");
					tester.lg.setHighPriority();

					if(totalScore > genPivotScore)
					{
						genPivotScore = totalScore;
						genPivotNotFound = true;
					}

					newlyAdded.Add(new Tuple<string, double>(constraint, totalScore));
					predScoreTable.Add(new Tuple<string, double>(constraint, totalScore));
				}
				#endregion

				if (!genPivotNotFound) //pivot found
					break;

				#region create_next_queue_by_combining_the_top_k
				newlyAdded.Sort((a,b)=> b.Item2.CompareTo(a.Item2));
				queue.Clear();
				int k=5;
				for(int i=0; i<Math.Min(k,newlyAdded.Count());i++)
				{
					for(int j=i+1; j<Math.Min(k,newlyAdded.Count());j++)
					{
						//combine i and j
						queue.Add(String.Join("^",newlyAdded[i].Item1.Split(new char[]{'^'}).Union(newlyAdded[j].Item1.Split(new char[]{'^'})).Distinct()));
					}
				}
				#endregion
			}
			return predScoreTable;
		}

		private List<Tuple<String,double>> topDownGenTemplate(Clause iterator, Tuple<Environment, List<Instruction>, double> history, Tester tester,
		                                                      double[,] leTestCorrMatrix, List<String> grounded, List<List<String>> plurality, 
		                                                      Dictionary<String, Double> weights)
		{
			/* Function Description: The main function that generates new VEIL template for a given scenario.
			 * The algorithm takes set of all atomic predicates P and find their factor solution. Then a top
             * K number of predicates are chosen and their combination is considered. If this increases the
             * factor likelihood then they are combined else not. */

			Environment envTest = history.Item1;
			List<Tuple<String,Double>> predScoreTable = new List<Tuple<string, double>> ();
			VerbProgram v = tester.veil.Find(veil_ => veil_.getName().Equals(iterator.verb.getName(), StringComparison.OrdinalIgnoreCase));

			String[] cstrSplitGen = this.generateRelevantSpace (iterator, history.Item1, history.Item2, grounded, plurality);
			String iterGenCstr = String.Join("^", cstrSplitGen);
			List<String> genConstraints = new List<String>(){iterGenCstr};

			bool genPivotNotFound = true;
			double genPivotScore = Double.NegativeInfinity;

			while(genPivotNotFound)
			{
				List<String> genConstraintsSpace = iterGenCstr.Split(new char[]{'^'}).ToList();
				for(int leaveOut = 0; leaveOut < genConstraintsSpace.Count(); leaveOut++)
				{
					List<String> tmp = genConstraintsSpace.ToList();
					tmp.RemoveAt(leaveOut);
					if(tmp.Count()==0)
						continue;
					genConstraints.Add(String.Join("^", tmp.ToArray()));
				}

				if(genConstraints.Count() == 0)
				{
					genPivotNotFound=false; 
					break;
				}

				String newConstraint = "";
				foreach(String constraint in genConstraints)
				{
					double totalScore = history.Item3;

					/* Feature computation stage
	                 * - Given envTest, iterator, set of predicates {q} and resultant instruction sequence {i}  
	                 *   1. Mapping Cost = LE cost + EE cost (at the moment)
	                 *   2. Instruction prior
	                 *   3. Verb-Correlation Score
	                 *   4. Description Length
	                 *   5. Trimming Cost 
	                 *   6. Avg. Frequency of predicate skeletal {q} */

					double mapCost = 0, dscpCost = 0, predSkeletalPrior = 0, predTotalPrior = 0, le = 0, leRecall = 0;

					List<String> objectCover = Global.getObjects(constraint, history.Item1);
					foreach(String objName in objectCover)
					{
						int j = envTest.objects.FindIndex(x => x.uniqueName.Equals(objName));
						double lePerObject = 0;
						for(int i=0; i<leTestCorrMatrix.GetLength(0);i++) 
							lePerObject = Math.Max(lePerObject,leTestCorrMatrix[i,j]);
						le = le + lePerObject;
					}

					for(int lang=0; lang < leTestCorrMatrix.GetLength(0); lang++)
					{
						double max = Double.NegativeInfinity;
						foreach(String objName in objectCover)
							max = Math.Max(max, leTestCorrMatrix[lang, envTest.objects.FindIndex(x=>x.uniqueName.Equals(objName))]);
						if (max < 0.85)
							max = 0;
						leRecall = leRecall + max;
					}

					leRecall = weights["w_ipr"]*leRecall/(leTestCorrMatrix.GetLength(0)+Constants.epsilon);
					mapCost= weights["w_le"]*le/ (objectCover.Count() + Constants.epsilon); //the EE cost is 0 as there is no reference
					String[] splitter = constraint.Split(new char[]{'^'});
					dscpCost= weights["w_dscp"] * splitter.Length;//generatedInst.Aggregate(0.0, (sum, n) => sum + n.norm());

					if(v!=null)
						predSkeletalPrior = 10*splitter.Aggregate(0.0,(sum,cstr_) => sum + v.fetchFrequency(cstr_))/(splitter.Length*v.totalFrequency() + Constants.epsilon);
					predTotalPrior = 100*splitter.Aggregate(0.0,(sum,cstr_) => sum + this.ftr.getPredicateFreq(cstr_))/(splitter.Length*this.ftr.zPredFreq + Constants.epsilon);
					totalScore = totalScore + mapCost + leRecall + dscpCost + predSkeletalPrior + predTotalPrior; 

					tester.lg.writeToFile("Generated Template "+predScoreTable.Count()+"<ul>"+
					                      "<li><b>Constraint</b> "+constraint+"</li>"+
					                      "<li><b>Mapping Score</b> "+mapCost+"</li>"+
					                      "<li><b>Language Recall</b> "+leRecall+"</li>"+
					                      "<li><b>Description Length</b> "+dscpCost+"</li>"+
					                      "<li><b>Sentence Similarity</b> 0</li>"+
					                      "<li><b>Predicate Skeletal Prior</b> "+predSkeletalPrior+"</li>"+
					                      "<li><b>Predicate Total Prior</b> "+predTotalPrior+"</li>"+
					                      "<li><b>Total Score </b> = "+totalScore+"</li></ul>");

					if(totalScore > genPivotScore)
					{
						genPivotScore = totalScore;
						newConstraint = constraint.ToString();
					}

					predScoreTable.Add(new Tuple<string, double>(constraint, totalScore));
				}
				genConstraints.Clear();
				if(newConstraint == null || newConstraint.Equals(iterGenCstr))
					genPivotNotFound=false;
				else iterGenCstr = newConstraint;
			}
			return predScoreTable;
		}

		private Tuple<List<Instruction>, int, Double> rss2015NodePredicates(Clause iterator, Tuple<Environment, List<Instruction>, double> history,
		                                                                    Tester tester, List<Tuple<Environment, List<Instruction>, double>> entryThisClause,
		                                                                    Dictionary<String, Double> weights, List<object> param)
		{
			/* Function Description: For a given node, the history (given environment, instruction so far, score so far) 
             * this algorithm updates the entryThisClause vector by performing inference steps on this clause node.
             * The algorithm also return the best score and corresponding instruction sequence. */

			if (iterator.isCondition) //if clause represents a condition
			{
				Instruction marker = new Instruction ();
				marker.setNameDescription ("$Conditional",new List<String>());
				history.Item2.Add(marker);
				entryThisClause.Add (history);
				return new Tuple<List<Instruction>, int, double>(history.Item2, -1, history.Item3);
			}

			Environment envTest = history.Item1;
			List<Instruction> output = null;
			double maxScoreLeaf = Double.NegativeInfinity;
			int init = entryThisClause.Count ();

			List<Object> objList = envTest.objects; 
			List<List<String>> plurality = new List<List<String>> ();

			double[,] leTestCorrMatrix = envTest.getLECorrMatrix (iterator, history.Item2, this.sensim, this.ftr);
			List<String> grounded = new List<String> ();
			String sdt = "";

			for (int i=0; i<leTestCorrMatrix.GetLength(0); i++)
			{
				String mainNoun = iterator.lngObj [i].getName ();
				int maxIndex = 0;
				List<String> plurality_ = new List<string> () { objList[0].uniqueName };
				for (int j=1; j<objList.Count(); j++) 
				{
					if (leTestCorrMatrix [i, j] > leTestCorrMatrix [i, maxIndex]) 
					{
						maxIndex = j;
						plurality_.Clear ();
						plurality_.Add (objList[j].uniqueName);
					}
					else if (leTestCorrMatrix [i, j] == leTestCorrMatrix [i, maxIndex]) 
						plurality_.Add (objList[j].uniqueName);
				}
				if (leTestCorrMatrix [i, maxIndex] <= 0.8) //if the max has low confidence then ignore the list
					plurality_.Clear ();
				//if the mainNoun is not in plural form then make a choice
				if (!mainNoun.EndsWith ("s") && plurality_.Count() > 1) //hack for plural
					plurality_.RemoveRange (1, plurality_.Count()-1);
				grounded = grounded.Union (plurality_).ToList();
				sdt = sdt + i.ToString () + ". " + mainNoun + " maps to " + String.Join(", ",plurality_) + " Cost: "
					+ leTestCorrMatrix [i, maxIndex] + " MaxFreq: " + plurality_.Count() + "<br/>";
				plurality.Add (plurality_);
			}

			tester.lg.writeToFile (sdt);
			tester.lg.writeToFile("<div> <button onclick='show(this)'>Clause - "+iterator.verb.getName()+"</button> <div style='display:none;'>");

			#region apply_inference_steps
			/* - iterate over each dataset D_iterator = { {(c,i,e,z,\xi) \in D such that v(C)=v(iterator) }
			 * - fetch the flipped-predicates [post-conditions] of each environment
			 * - call the symbolic planner to fulfill these post conditions
			 * - infer I
			 * - update alpha tables */

			List<Tuple<String,double>> predScoreTable = new List<Tuple<String,double>>();

			VerbProgram v = tester.veil.Find(veil_ => veil_.getName().Equals(iterator.verb.getName(), StringComparison.OrdinalIgnoreCase));
			List<VeilTemplate> vtList = null;
			if(v == null)
				vtList = new List<VeilTemplate>();
			else vtList = v.getProgram();

			int count = 0;
			foreach (VeilTemplate vt in vtList)
			{
				if(!(bool)param[0])
					continue;
				tester.lg.writeToFile("<br/>Count = "+count+" of "+vtList.Count());
				Tuple<int[], double, String> mappingResult = this.map.mappingPredicates(vt, iterator, envTest, history.Item2, weights);
				if(mappingResult ==null)
				{
					tester.lg.writeToFile("No appropriate mapping was found");
					continue;
				}

				String iterConstraints = String.Join("^",this.instantiatePredicates(vt, mappingResult.Item1, envTest).Distinct().ToList());

				if(iterConstraints.Length==0)
				{
					count++;
					continue;
				}

				bool pivotNotFound = true;
				double pivotScore = Double.NegativeInfinity;
				List<String> constraints = new List<String>(){iterConstraints};

			    while(pivotNotFound)
				{
					/* We already have C_i that is the iterator, we also know the starting environment.
					 * We call the symbolic planner that fulfills the instantiated constraint. */
					//List<String> constraintsSpace = iterConstraints.Split(new char[]{'^'}).ToList();
					/*for(int leaveOut = 0; leaveOut < constraintsSpace.Count(); leaveOut++)
					{
						List<String> tmp = constraintsSpace.ToList();
						tmp.RemoveAt(leaveOut);
						if(tmp.Count()==0)
							continue;
						constraints.Add(String.Join("^",tmp.ToArray()));
					}*/
					if(constraints.Count()==0)
					{
						pivotNotFound=false; 
						break;
					}

					String newConstraints = null;

					foreach (String constraint_ in constraints)
					{
						/* For each constraint, find the instruction sequence that satisfies it
                         * Each constraint is of type - predicate^predicate^.... where these
                         * predicates need to be satisfied */

						String cstrlog = "";
						String preNoiseConstraint = constraint_.ToString();
						String constraint = this.removeNoise(constraint_, plurality, history.Item2, history.Item1);
						if(constraint.Length == 0)
							continue;

						if(!preNoiseConstraint.Equals(constraint))
							cstrlog= "Pre Noise Constraint was "+preNoiseConstraint;

						String cstr = this.expansion(plurality, constraint);
						String[] cstrSplit = cstr.Split(new char[]{'^'});

						/* Feature computation stage
                         * - Given envTest, iterator, set of predicates {q} and resultant instruction sequence {i}  
                         *   1. Mapping Cost (which takes into account 5 features)
                         *   2. Sentence Similarity
                         *   3. Language Recall
                         *   4. Avg. Frequency of predicate skeletal {q}
                         *   5. Total Frequency of predicate {q,e}  */
						 
						double mapCost = 0,dscpCost = 0, sentenceSim = 0, predSkeletalPrior = 0, predTotalPrior = 0, 
							   leRecall= 0, endState = 0, bias=0, trans=0, argTrans= 0;

						mapCost= mappingResult.Item2; //Mapping-Cost
						dscpCost= weights["w_dscp"] * cstrSplit.Length;
						String sensSimLog = "";

						if(vt.cls_.sentence!=null && iterator.sentence!=null)
						{
							List<String> trainWords = vt.cls_.getWords();//sentence.Split(new char[]{' '}).Select(x=>x.Trim()).ToList();
							List<String> testWords = iterator.getWords();//sentence.Split(new char[]{' '}).Select(x=>x.Trim()).ToList();
							trainWords.RemoveAll(x=>x.Length==0);
							testWords.RemoveAll(x=>x.Length==0);
							Tuple<double,string> res = Global.jaccardIndex(trainWords, testWords);
							sentenceSim = weights["w_sensim"]*res.Item1;
							sensSimLog = res.Item2;
						}
						else sentenceSim = 0;

						List<String> objectCover = Global.getObjects(cstr, history.Item1);
						for(int lang=0; lang < leTestCorrMatrix.GetLength(0); lang++)
						{
							double max = Double.NegativeInfinity;
							foreach(String objName in objectCover)
								max = Math.Max(max, leTestCorrMatrix[lang, envTest.objects.FindIndex(x=>x.uniqueName.Equals(objName))]);
							if(max<0.85)
								max=0;
							leRecall = leRecall + max;
						}
						leRecall = weights["w_lerecall"]*leRecall/(leTestCorrMatrix.GetLength(0)+Constants.epsilon);

						predSkeletalPrior = weights["w_prior"]*cstrSplit.Aggregate(0.0,(sum,cstr_) => sum + v.fetchFrequency(cstr_))/(cstrSplit.Length*v.totalFrequency() + Constants.epsilon);
						predTotalPrior = weights["w_argprior"]*cstrSplit.Aggregate(0.0,(sum,cstr_) => sum + this.ftr.getPredicateFreq(cstr_))/(cstrSplit.Length*this.ftr.zPredFreq + Constants.epsilon);

						Tuple<double,string> relres = this.ftr.fetchRelationshipFeature(iterator, plurality, constraint);
						double relfeature = weights["w_rel"]*relres.Item1;
						String endStateLog = "Not-End";
						if (iterator.children == null || iterator.children.Count() == 0)
						{
							endStateLog="";
							endState = weights["w_end"]*this.ftr.getEndStateProbability(constraint);
						}

						trans = weights["w_trans"]*this.ftr.fetchTransitionProbability(cstr, this.oldvalue);
						argTrans = weights["w_argtrans"]*this.ftr.fetchArgTransitionProbability(cstr, this.oldvalue);
					
						double exponent = mapCost + leRecall + dscpCost + sentenceSim +  predSkeletalPrior 
										  + predTotalPrior + relfeature + endState + bias + trans + argTrans;
						double totalScore = history.Item3*Math.Exp(exponent);

						tester.lg.setLowPriority();
						tester.lg.writeToFile("Template Count ["+count+"]<ul>"+
						                      "<li><b>Constraint:</b>"+cstr+" <br/>["+ cstrlog +"] </li>"+
						                      "<li><b>Mapping Score</b> "+mappingResult.Item2+" [Log : "+mappingResult.Item3+"]</li>"+
						                      "<li><b>Language Recall</b> "+leRecall+"</li>"+
						                      "<li><b>Description Length</b> "+dscpCost+"</li>"+
						                      "<li><b>Sentence Similarity</b> "+sentenceSim+"  ["+sensSimLog+"] </li>"+
						                      "<li><b>Predicate Skeletal Prior</b> "+predSkeletalPrior+"</li>"+
						                      "<li><b>Predicate Total Prior</b> "+predTotalPrior+"</li>"+
						                      "<li><b>Relationship feature</b> "+relfeature+" ["+relres.Item2+"] </li>"+
						                      "<li><b>End State</b> "+endState+" ["+endStateLog+"]</li>"+
						                      "<li><b>Transition Prob.</b> "+trans+"</li>"+
						                      "<li><b>Arg Transition Prob.</b> "+argTrans+"</li>"+
						                      "<li><b>Bias</b> "+bias+"</li>"+
						                      "<li><b>Total Score </b> := "+totalScore+" [ history: "+history.Item3+", exponent"+exponent+" ]</li></ul>");
						tester.lg.setHighPriority();

						if(totalScore > pivotScore)
						{
							pivotScore = totalScore;
							newConstraints = cstr.ToString();
						}

						predScoreTable.Add(new Tuple<String,double>(cstr, totalScore));
					}
					constraints.Clear();

					if(newConstraints==null || newConstraints.Equals(iterConstraints))
						pivotNotFound=false;//pivot has been found
					else iterConstraints = newConstraints;
					pivotNotFound = false;
				}

				count++;
				#endregion
			}

			int numVEILTemplates = predScoreTable.Count(); //number of VEIL templates

			#region GenTemplate
			/* GEN-Template Stage: Maybe the given templates are all wrong, so we
			 * create additional template as possible samples. */
			if((bool)param[1])
			{
				predScoreTable = predScoreTable.Concat(this.bottomUpGenTemplate(iterator, history, tester, leTestCorrMatrix,
				                                                                grounded, plurality, weights)).ToList();
			}
			tester.lg.writeToFile("</div></div>");
			#endregion

			List<int> indices = new List<int> (); //indices
			for (int i=0; i<predScoreTable.Count(); i++)
				indices.Add(i);

			//predScoreTable.Sort ((a,b) => b.Item2.CompareTo(a.Item2));

			for (int i=0; i<predScoreTable.Count(); i++) 
			{
				int placement = i; //placement of element at i
				for (int j=i+1; j<predScoreTable.Count(); j++) 
				{
					if(predScoreTable[j].Item2 > predScoreTable[placement].Item2)
						placement = j;
				}

				if (placement != i) //if condition is true then sawp elements as position i and placement
				{
					Tuple<String, double> tmpswap = predScoreTable[i];
					int indicestmp = indices[i];
					predScoreTable [i] = new Tuple<String, double> (predScoreTable [placement].Item1, predScoreTable [placement].Item2);
					predScoreTable [placement] = new Tuple<string, double> (tmpswap.Item1, tmpswap.Item2);
					indices [i] = indices [placement];
					indices [placement] = indicestmp;
				}
			}

			#region find_valid_instruction_assignment_with_maximum_factor_score
			int which = 0;
			foreach (Tuple<String, double> discoveredPred in predScoreTable) 
			{
				which++;
				tester.lg.writeToFile("<br/>Picking "+discoveredPred.Item1+" at score = "+discoveredPred.Item2+"<br/>");
				List<Instruction> instruction = tester.symp.satisfyConstraints (envTest, discoveredPred.Item1);
				if (instruction == null) 
				{
					tester.lg.writeToFile("Which gave me Null results :-(<br/>");
					continue;
				}

				this.oldvalue = discoveredPred.Item1;

				String logs = "Found at (" + which + "/" + predScoreTable.Count () + ") Instruction is " + instruction.Aggregate ("", (acc,inst) => acc + "; " + inst.getName ());

				//if the used template is a generatedTemplate then create a new VEIL-template from it for future use
				if((bool)param[2] && indices[which-1] >= numVEILTemplates)
				{
					#region generate_new_veil_template_with_this_predicates
					Environment copiedEnv = history.Item1.makeCopy();
					VeilTemplate generatedTemplate = new VeilTemplate(discoveredPred.Item1.Split(new char[]{'^'}).ToList(), iterator, copiedEnv, -1, this.sml);//new VeilTemplate(iterator, copiedInst, copiedEnv, -1, this.sml);
					this.lg.writeToFile("Generating template for the verb " +iterator.verb.getName()+" with predicates " +discoveredPred.Item1 );
					tester.addVEILTemplate(generatedTemplate);
					#endregion
				}

				tester.lg.writeToFile (logs+"<br/>");
				tester.lg.writeToFile ("<b>Choosing "+discoveredPred.Item1+"</b><br/>");
				List<Instruction> entire = history.Item2.ToList ().Concat (instruction).ToList ();

				if (iterator.children == null || iterator.children.Count () == 0) //iterator is a leaf
				{
					if (discoveredPred.Item2 > maxScoreLeaf) 
					{
						output = entire;
						maxScoreLeaf = discoveredPred.Item2;
					}
				}

				Console.WriteLine("Constraint "+discoveredPred.Item1+" gives instruction = " +instruction.Aggregate("",(acc,x)=>acc+"; "+x.getName()));
				Environment iterEnv_ = tester.sml.executeList (instruction, envTest);
				Instruction marker = new Instruction ();
				marker.setNameDescription ("$Verb " + iterator.verb.getName () + " Count = " + count, new List<String> ());
				entire.Add (marker);
				entryThisClause.Add (new Tuple<Environment, List<Instruction>, double> (iterEnv_, entire, discoveredPred.Item2));
				break;
			}
			#endregion

			if(init == entryThisClause.Count())
			{
				Instruction marker = new Instruction ();
				marker.setNameDescription ("$Stupid Grounding",new List<String>());
				history.Item2.Add(marker);
				entryThisClause.Add (history);
			}

			if (output == null)
			{
				output = history.Item2;
				maxScoreLeaf = history.Item3;
			}
			return new Tuple<List<Instruction>, int, double>(output, -1, maxScoreLeaf);
		}

		public String removeNoise(String constraint, List<List<String>> plurality, List<Instruction> instPrev, Environment env)
		{
			/* Function Description: Remove all the noisy predicates in constraint, that
			 * does not contain an object/state from plurality */

			List<String> predicates = constraint.Split (new char[] { '^' }).ToList();
			List<String> noiseFree = new List<string> ();
			List<String> relevantObjects = plurality.Aggregate (new List<String> (), (acc,x) => acc.Union (x).ToList());

			for (int k=instPrev.Count()-2; k>=0; k--) //the last one is $ marked
			{
				if (instPrev [k].getControllerFunction ().StartsWith ("$"))
					break;
				relevantObjects = relevantObjects.Union (instPrev [k].returnObject ()).ToList ();
			}

			foreach (String predicate in predicates) 
			{
				String[] words = Global.getAtomic (predicate).Item2.Split (new char[] { ' ' });
				Tuple<bool,string> res = Global.getAtomic (predicate);
				int satisfy = env.isSastified (res.Item2);

				if (res.Item1 && satisfy == 1)
					satisfy = 0;
				else if (res.Item1 && satisfy == 0)
					satisfy = 1;

				if (relevantObjects.Contains (words [1]) || relevantObjects.Contains (words [2]) || satisfy!=0)
				{
					noiseFree.Add (predicate);
					continue;
				}
				else if (words [0].Equals ("state")) 
				{
					/* if the statename was the name of a category of relevant objects or 
					 * is the name of a state that is present in a relevant object and is true */

					if (relevantObjects.FindIndex (x => Global.base_ (x).Equals (words [2], StringComparison.OrdinalIgnoreCase) || 
					                               env.findObject(x).checkStateAndVal(words[2],"True")) != -1 ) 
					{
						noiseFree.Add (predicate);
						continue;
					}
				}
			}

			return String.Join ("^", noiseFree);
		}
    }
}
